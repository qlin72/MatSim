# Evaluate on MatSim benchmark (Works on files Generated by RunNetOnFolder.py)
# Receive a file json with descriptors arrange in a tree strcutres (that replicate input folder and subfolder structre).
# Assume all descriptor in the same subfolder are of the same subclass
#...............................Imports..................................................................
import os
import random
import json
import numpy as np
import argparse
##os.system("cls")
##################################Input paramaters#########################################################################################
parser = argparse.ArgumentParser(description = 'take descriptor files generate by RunNetOnFolder and get accuracy statitics')
parser.add_argument('--descriptor_file', default="/home/breakeroftime/Desktop/Dataset_Materials/Converted//matsim_Masked.json", type=str, help=' input json file with descriptors, generatee by RunNetOnFolder.py')
parser.add_argument('--test_set', default=  1, type = int, help="Benchmarks set Set 1 subclass and states , Set 2. Random material on random on random objects")
parser.add_argument('--mode', default=  "subclass" , type = str, help='subclass/all "subclass": Match to only to images of the same superclass, "all" match between all images in the set')
parser.add_argument('--desc_length', default=  512 , type = int, help='descriptor length')
parser.add_argument('--random_match', default=  False , type = bool, help='replace descriptor with random  numbers for testing')
args = parser.parse_args()

# TestSet=1 # Benchmarks set" Set 1 subclass and states , Set 2. Random material on random on random objects
# mode= "all" # subclass/all "subclass": Match to only to images of the same superclass, "all" match between all images in the set
#
#
# # input json file with descriptors, generatee by RunNetOnFolder.py
# InpuFile =   r"logs/descriptor_dict.json"
# desc_length = 512


##############################################################################
if args.test_set==1:
    tree_depth=2#  the descriptor are arrange in tree structure were each layer is a more fine grain class, 1 mean single layer (one class per descriptor) 2 means 2 layer superclas+ subclass per descriptor
elif args.test_set==2:
    tree_depth = 1  #
    args.mode = "subclass" # Set 2


###RandomMatch=False # Replace descriptor with random descriptor
'''
subclass= compare subclass within the same super class,
all= compare all sub class to all subclass 
superclass = compare superclass to other super class
Note: superclasses are first order branches/folders subclass are second order folders
'''
###########################################################################################################################
'''
The following 
'''

def createDescList_1stOrderCoarseGrain_SuperClass(data,RandomMatch=False):
    '''Take the tree structure of the dictionary and replace it with flatt list of image descriptors and their class.
    Use bottum second order sub folders as main class and compare everyfolder to every folder.
    note that image of the same folder belong to the same class, and the lower the subfolder the more specific is the class'''
    descs = [] # list of all descriptors (for each decriptor also have its cat and other related data)
    descCat = {} # List of all descriptors divided by class
    for nm in data["dirs"]:# Use go over all first 2nd subfolders, use sub first order folder as class (but read files from second order subclass_
        subdirs1 = data["dirs"][nm]["dirs"] # second order file list
        descCat[nm] = {"sum_desc": np.zeros(args.desc_length), "num_samples": 0}
        for sdir1 in subdirs1: descCat[nm]["num_samples"]+=len(subdirs1[sdir1]["descs"]) # number of images of the same class
        for sdir1 in subdirs1:
            subdir2=subdirs1[sdir1]["descs"]

            for file_name in subdir2:
               descriptor = subdir2[file_name][1:-1]
               if type(descriptor) == str:
                        descriptor= np.fromstring(descriptor, dtype=np.float32, sep=', ') # get descriptor
               if RandomMatch:   descriptor= np.random.rand(args.desc_length)#
               descs.append({"file": file_name, "class": nm, "descs": descriptor, "num_samples": descCat[nm]["num_samples"],"id": len(descs)})
               descCat[nm]["sum_desc"] += descriptor # average descriptor for class
    return  descs#,descCat


# Put all the descriptors in one folder
def createDescList_2dOrderFineGrainAll(data,RandomMatch=False):
    '''Take the tree structure of the dictionary and replace it with flatt list of descriptor and their class.
    use bottum third order sub folders as main class and compare everyfolder to every folder.
    note that image of the same folder belong to the same class, and the lower the subfolder the more specific is the class'''
    descs = []  # list of all descriptors (for each decriptor also have its cat and other related data)
    descCat = {}  # List of all descriptors divided by class
    for nm in data["dirs"]:
        subdirs1 = data["dirs"][nm]["dirs"]


        for sdir1 in subdirs1:
            descCat[nm+sdir1] = {"sum_desc": np.zeros(args.desc_length), "num_samples": len(subdirs1[sdir1]["descs"])}
            subdir2=subdirs1[sdir1]["descs"]

            for file_name in subdir2:
               descriptor = subdir2[file_name][1:-1]
               if type(descriptor) == str:
                      descriptor= np.fromstring(subdir2[file_name][1:-1], dtype=np.float32, sep=', ') #
               if RandomMatch:  descriptor= np.random.rand(args.desc_length)#
               descs.append({"file": file_name, "class": nm+sdir1, "descs": descriptor, "num_samples": descCat[nm+sdir1]["num_samples"],"id": len(descs)})
               descCat[nm+sdir1]["sum_desc"] += descriptor
    return  descs#,descCat
#####################################################################################################################3
# Put all the descriptors in one folder
def createDescListSubClass(data,RandomMatch=False):
    '''Take the tree structure of the dictionary and replace it with flatt list of descriptor and their class.
    use bottum third order sub folders as main class but compare it only to image of the same coarse grain class.
    Hence only compare images belonging to the same super cclass
    note that image of the same folder belong to the same class, and the lower the subfolder the more specific is the class'''
    descs = []  # list of all descriptors (for each decriptor also have its cat and other related data)
 #   descCat = {}  # List of all descriptors divided by class
    for nm in data["dirs"]: # Use go over all subfolders, use sub folder as class
        subdir = data["dirs"][nm]["descs"]
     #   descCat[nm] = {"sum_desc": np.zeros(1536), "num_samples": len(subdir)}
        for file_name in subdir: # Get descriptor for every file in subfolder
            descriptor = subdir[file_name][1:-1]
            if  type(descriptor) == str:
                   descriptor= np.fromstring(descriptor, dtype=np.float32, sep=', ') #
            if RandomMatch:  descriptor= np.random.rand(args.desc_length)#
            descs.append({"file": file_name, "class": nm, "descs": descriptor, "num_samples": len(subdir),"id": len(descs)})
          #  descCat[nm]["sum_desc"] += descriptor #use sub folder as class
    return  descs#,descCat

#############################################################################3
def  createMatchList(descs):
       '''Match all descriptor to all other descriptor and create for each image descriptor similarity score for all other descriptor'''
       random.shuffle(descs)
       descmat=np.zeros([len(descs),descs[0]["descs"].shape[0]])
       print('turn descriptor to list')
       for i1 in range(len(descs)):
           descmat[i1] = descs[i1]["descs"].astype(np.float32)
       print('get top match')
       for i1 in range(len(descs)):
           match_scores=(descmat[i1]*descmat).sum(1)
           top_matches=np.argsort(match_scores)[-21:][::-1][1:]
           descs[top_matches[0]]
           descs[i1]['Top1MatchClass']=descs[top_matches[0]]["class"]
           descs[i1]['Top1_MatchCorrect']  = (descs[i1]['class']==descs[i1]['Top1MatchClass'])

       print('get statitics')

       num_tp={}
       num_occurences={}
       for i1 in range(len(descs)):
           if not descs[i1]["class"] in num_tp:
               num_tp[descs[i1]["class"]] = 0
               num_occurences[descs[i1]["class"]] = 0
           num_occurences[descs[i1]["class"]] += 1
           if  descs[i1]['Top1_MatchCorrect'] :  num_tp[descs[i1]["class"]] += 1

       print('display statics')
       accuracy_per_cat = {}
       accuracy_by_cat=0
       accuracy_by_sample=0
       num_cats=len(num_occurences.keys())
       num_samples=0

       print("---------------------------------------------------------------")
       for ct in num_occurences:
           accuracy_per_cat[ct]=num_tp[ct]/num_occurences[ct]
           accuracy_by_cat+=accuracy_per_cat[ct]
           accuracy_by_sample += num_tp[ct]
           num_samples+=num_occurences[ct]
           print(ct,"  accuracy=",accuracy_per_cat[ct])
       print("all set")
       accuracy_by_cat/=num_cats
       accuracy_by_sample/=num_samples
       print("all set................\nAccuracy By cat=",accuracy_by_cat,  "\n Accuracy per image=",accuracy_by_sample)
       return accuracy_per_cat,accuracy_by_cat,accuracy_by_sample

#******************************************************************************************

##############################################################3
def GetStatistics(data,votes,mode,RandomMatch=False):
   '''get statics of accuracy '''
# arrange descriptor in list structure
   print("Creatig descriptor list")
   if mode=="subclass":#all, superclass
          descs =createDescListSubClass(data,RandomMatch)
   if mode=="all":#all, superclass
          descs =createDescList_2dOrderFineGrainAll(data,RandomMatch)
   if mode == "superclass":  # all, superclass
       descs = createDescList_1stOrderCoarseGrain_SuperClass(data,RandomMatch)
   print("creating top match list")
#   match with other descriptors and get similarity score and statistics
   accuracy_per_cat,accuracy_by_cat,accuracy_by_sample=createMatchList(descs)
   return  accuracy_per_cat,accuracy_by_cat,accuracy_by_sample


###################################################################################################################
if __name__ == "__main__":
    with open(args.descriptor_file) as fp2:
        data = json.load(fp2)
      #  print(data)
        st=[]
        sum_mean = 0
        #********************************
        for i in range(1):
            if  (args.mode=="superclass" or args.mode=="all" and tree_depth==2) or (args.mode=="subclass" and tree_depth==1):
               accuracy_per_cat,accuracy_by_cat,accuracy_by_sample = GetStatistics(data, votes=1,mode=args.mode,RandomMatch=args.random_match)
               print("Accuracy By cat=",accuracy_by_cat,   "        Accuracy per image=",accuracy_by_sample)
               sum_mean += accuracy_by_cat
            #*************************************
            else:
                for i in range(1):
                    for nm in data["dirs"]:
                        print("-----------scene:", nm, "-------------------------------------------------")
                        accuracy_per_cat,accuracy_by_cat,accuracy_by_sample  =GetStatistics(data["dirs"][nm],votes=1,mode=args.mode,RandomMatch=args.random_match)
                        st.append(accuracy_by_cat)
                        print("-----------scene:",nm,"-------------------------------------------------")
                        print("Accuracy By cat=",accuracy_by_cat,   "        Accuracy per image=",accuracy_by_sample)
                        print("*************************************************************************************")

                    print("mean ",sum(st)/len(st))
                    sum_mean+=sum(st)/len(st)
        print("\n\n Average accuracy for all class:",sum_mean/1)
        print(sum_mean/1)
        #
        # print("mean ", sum(stCats) / len(st))
        #     # print(stat_cat)
        #     # statitics[nm]=stat_cat

